/*
 * Copyright (c) 2018 Smilo Platform B.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.smilo.commons.ledger;

import io.smilo.commons.HashUtility;
import io.smilo.commons.db.Store;
import org.apache.log4j.Logger;
import org.springframework.stereotype.Component;

import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.ArrayList;


/**
 * This class is used to generate Merkle Trees from private keys. The top of the generated Merkle Tree is the Smilo address of the tree.
 * The network supports Merkle Trees between 14 and 18 layers large.
 * The bottom layer of the Merkle Tree is created by generating individual groups of Lamport Signature Private Keys, then hashing them to a Lamport
 * Signature Public Key.
 * Each Lamport Signature Private Key is used to sign exactly one transaction.
 * A Merkle Tree with 14 layers can sign 8192 transactions, and one with 18 layers can sign 131,072 transactions.
 * The Lamport Signature Private Key Parts are generated by seeding a SecureRandom object with a byte array representation of the private key.
 * As they are trivial to produce, are relatively large, and can be produced on-demand for signatures, these Lamport Private Keys are generated
 * when they are needed, rather than stored.
 * The higher layers of the Merkle Tree are easy to store, and take a long time to generate, and therefore are stored on the hard drive.
 * The entire tree could be deterministically reproduced for each signature, if desired.
 * Rather than generating all of the Lamport Signatures from the same SecureRandom object, the SecureRandom object seeded with the private key
 * is used to generate all of the private seeds, one for each Lamport Private Key. This reduces the time to produce Lamport Private Keys
 * for signatures by a factor of nearly 2*SIGNATURE_BITS.
 */
@Component
public class MerkleTreeGenerator {

    private static final Logger LOGGER = Logger.getLogger(MerkleTreeGenerator.class);
    public static final int SIGNATURE_BITS = 100; //Each Lamport Private Key will contain 2x this number of Private Lamport Key Parts. Not used, only for information.
    private static final String CS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; //Character set used in Lamport Private Key Parts
    public static final int LAMPORT_PRIVATE_PART_SIZE = 20; //Maximum size of Lamport Private Part. At 1E12 tries per second, would take 22,337,120,292,586,187 years to brute-force one.  Not used, only for information.

    public static final String SOFTWARE_VERSION = "0.0.1a";
    private final Store store;
    private static final String COLLECTION_NAME = "merkel";

    /**
     * Constructor ensures existance of address folder for storing the Merkle Trees. Also checks for availability of SHA1PRNG.
     */
    public MerkleTreeGenerator(Store store) {
        this.store = store;
        store.initializeCollection(COLLECTION_NAME);
        try {
            SecureRandom.getInstance("SHA1PRNG"); //Test for SHA1PRNG being available. Should never fail.
        } catch (Exception e) {
            LOGGER.error("NO SHA1PRNG SUPPORT! EXITING APPLICATION", e);
        }
    }

    /**
     * This method will produce a Merkle Tree for the given privateKey and number of layers.
     * All use of SecureRandom is seeded by the privateKey, so multiple calls to generateMerkleTree() with the same
     * parameters will yield the exact same Merkle Tree.
     * Produced Merkle Tree is saved to the addresses folder.
     * Note that layers include the bottom hashed private key parts, as well as the top, which contains the address.
     *
     * @param privateKey A String which holds the plaintext private key of an address, generally generated by SecureStringGenerator.
     * @param numLayers The number of layers to build the Merkle Tree out of. A Merkle Tree of n layers can sign 2^(n-1) transactions.
     *
     * @return boolean A boolean indicating whether the generation and saving of the Merkle Tree was successful.
     */
    public String generateMerkleTree(String privateKey, int numLayers, int numThreads, int keysPerThread) {
        if (numThreads < 1) {
            numThreads = 1;
        }
        if (privateKey == null) {
            return null;
        }
        return generateMerkleTreeFromLeafLayer(numLayers, generateLeafLayer(privateKey, numLayers, numThreads, keysPerThread));
    }

    private String [] generateLeafLayer(String privateKey, int numLayers, int numThreads, int keysPerThread) {
        ArrayList<LamportThread> threads = new ArrayList<>(); //ArrayList to hold worker threads
        String [] merkelKeys = new String[(int) Math.pow(2, (numLayers - 1) )];
        for (int j = 0; j < numThreads; j++) {
            threads.add(new LamportThread()); //Initial setup, sanity check, and to make the normal thread removal loop not require a conditional.
        }
        try {
            //SecureRandom seeded by privateKey will be used to generate private seeds for all Merkle Trees
            SecureRandom generatePrivateSeeds = SecureRandom.getInstance("SHA1PRNG");
            generatePrivateSeeds.setSeed(privateKey.getBytes());
            //First layer will hold hashes of Lamport Private Key bases, which must be generated
            long lastPrint = System.currentTimeMillis();
            for (int i = 0; i < (int) Math.pow(2, (numLayers - 1)); i++) //2^(numLayers-1) is how many Lamport Signatures need to be generated. Also max possible signatures.
            {
                LOGGER.debug(i + "/" + Math.pow(2, (numLayers - 1)));
                double increaseInKeys = (numThreads * keysPerThread);
                double timeChange = System.currentTimeMillis() - lastPrint;
                lastPrint = System.currentTimeMillis();
                double keysPerSecond = increaseInKeys / (timeChange / 1000);
                LOGGER.debug("Rate: " + keysPerSecond + " keys per second.");
                //generatePrivateSeeds.nextBytes(privateSeed); //privateSeed now holds the ith private seed for Lamport Signature Generation
                for (int j = 0; j < numThreads; j++) //Clear thread pool
                {
                    threads.remove(0);
                }
                for (int j = 0; j < numThreads; j++) //Create new threads for generating public keys
                {
                    threads.add(new LamportThread());
                }
                for (int j = 0; j < numThreads; j++) //Fill in seeds for all generation threads
                {
                    byte[][] seeds = new byte[keysPerThread][100]; //100 bits used as the private key
                    for (int q = 0; q < keysPerThread; q++) {
                        generatePrivateSeeds.nextBytes(seeds[q]);
                    }
                    threads.get(j).setData(seeds, keysPerThread);
                }
                for (int j = 0; j < numThreads; j++) //Start worker threads
                {
                    threads.get(j).start();
                }
                int offset = 0; //Handle increments to i to keep on track with multithreaded progress. Originally, this for loop ran once for every public Lamport keyset.
                for (int j = 0; j < numThreads; j++) {
                    threads.get(j).join(); //Wait for thread to finish
                    String[] keys = threads.get(j).getPublicKeys(); //Retrieve public keys in order
                    if((int) Math.pow(2, (numLayers - 1)) > (i + offset + keysPerThread)){
                        // write all keys
                        System.arraycopy(keys, 0, merkelKeys, i + offset, keysPerThread);
                    } else {
                        // split 0 -> Math.pow(2, (numLayers - 1) - i - offset
                        System.arraycopy(keys, 0, merkelKeys, i + offset, (int) (Math.pow(2, (numLayers - 1) )- i - offset));
                    }
                    offset += keysPerThread; //Add keysPerThread each time through the loop to keep offset at the proper location in the base tree
                }
                i += (numThreads * keysPerThread) - 1; //Subtract one as for loop adds 1 every loop
            }

        } catch (Exception e) {
            LOGGER.error("Unable to generate scratch file", e);

        }
        return merkelKeys;
     }

    /**
     * This method will produce a Merkle Tree for the given privateKey and number of layers.
     * All use of SecureRandom is seeded by the privateKey, so multiple calls to generateMerkleTree() with the same
     * parameters will yield the exact same Merkle Tree.
     * Produced Merkle Tree is saved to the addresses folder.
     * @param numLayers The number of layers to build the Merkle Tree out of. A Merkle Tree of n layers can sign 2^(n-1) transactions.
     * Note that layers include the bottom hashed private key parts, as well as the top, which contains the address.
     * @return boolean A boolean indicating whether the generation and saving of the Merkle Tree was successful.
     */
    public String generateMerkleTreeFromLeafLayer(int numLayers, String [] merkelKeys) {
        try {
            String layer[][] = new String[ numLayers] [ (int) Math.pow(2, (numLayers - 1) )];

            layer[0] = merkelKeys;
            int readCount = 0;
            long previousTime = System.currentTimeMillis();
            for (int i = 1; i < numLayers; i++) {
                String temp = null;
                int k = 0;
                for (String srt:layer[i-1]) {
                    if (temp == null) {
                        temp = srt;
                    } else {
                        layer[i][k] = HashUtility.digestSHA256ToBase64(temp + srt);
                        k++;
                        temp = null;
                    }
                    if (srt == null) continue;
                    readCount++;
                    if (readCount % 100000 == 0) {
                        LOGGER.debug((100000.0) / (((double) System.currentTimeMillis() - (double) previousTime) / 1000.0) + " entries per second.");
                        previousTime = System.currentTimeMillis();
                    }
                }

            }
            String preAddress = HashUtility.digestSHA256ToBase32(layer[numLayers-2] [0] + layer[numLayers-2] [1]);
            String address; //S# + pre-address + first 4 characters of hash of pre-address (sanity check, protect against mistypes)
            if (numLayers == 14) {
                address = "S1" + preAddress + HashUtility.digestSHA256ToBase32("S1" + preAddress).substring(0, 4); //14-layer is a C1 address
            } else if (numLayers == 15) {
                address = "S2" + preAddress + HashUtility.digestSHA256ToBase32("S2" + preAddress).substring(0, 4); //15-layer is a C2 address
            } else if (numLayers == 16) {
                address = "S3" + preAddress + HashUtility.digestSHA256ToBase32("S3" + preAddress).substring(0, 4); //16-layer is a C3 address
            } else if (numLayers == 17) {
                address = "S4" + preAddress + HashUtility.digestSHA256ToBase32("S4" + preAddress).substring(0, 4); //17-layer is a C4 address
            } else if (numLayers == 18) {
                address = "S5" + preAddress + HashUtility.digestSHA256ToBase32("S5" + preAddress).substring(0, 4); //18-layer is a C5 address
            } else //Not a Smilo address!
            {
                address = "X1" + preAddress + HashUtility.digestSHA256ToBase32("X1" + preAddress).substring(0, 4); //Non-supported layer
            }

            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(layer);

            oos.flush();
            store.put(COLLECTION_NAME, address.getBytes(StandardCharsets.UTF_8), bos.toByteArray());
            return address;
        } catch (Exception e) {
            LOGGER.error("Unable to generate merkle tree from scratch file");
        }
        return null;
    }

    public int getAddressNumberOfLayers(String address) {
        switch (address.substring(0,2)) {
            case "S1" : return 14;
            case "S2" : return 15;
            case "S3" : return 16;
            case "S4" : return 17;
            case "S5" : return 18;
            default : return -1;
        }
    }

    public boolean hasMerkelTree(String address) {
        byte[] result = store.get(COLLECTION_NAME, address.getBytes(StandardCharsets.UTF_8));
        return result != null && result.length > 0;
    }
}
